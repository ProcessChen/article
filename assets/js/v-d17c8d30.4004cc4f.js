(self.webpackChunkvuepress_starter=self.webpackChunkvuepress_starter||[]).push([[614],{4891:(l,n,e)=>{"use strict";e.r(n),e.d(n,{data:()=>s});const s={key:"v-d17c8d30",path:"/frontend/Javascript.html",title:"javascript",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"类型和语法",slug:"类型和语法",children:[{level:3,title:"数据类型",slug:"数据类型",children:[]},{level:3,title:"类型判断",slug:"类型判断",children:[]}]},{level:2,title:"作用域和闭包",slug:"作用域和闭包",children:[]},{level:2,title:"原型链",slug:"原型链",children:[]}],filePathRelative:"frontend/Javascript.md",git:{updatedTime:1619325095e3,contributors:[]}}},5135:(l,n,e)=>{"use strict";e.r(n),e.d(n,{default:()=>G});var s=e(6252);const a=e.p+"assets/img/prototype.8f94eb10.png",m=(0,s.Wm)("h1",{id:"javascript"},[(0,s.Wm)("a",{class:"header-anchor",href:"#javascript"},"#"),(0,s.Uk)(" javascript")],-1),t=(0,s.Wm)("h2",{id:"类型和语法"},[(0,s.Wm)("a",{class:"header-anchor",href:"#类型和语法"},"#"),(0,s.Uk)(" 类型和语法")],-1),u=(0,s.Wm)("h3",{id:"数据类型"},[(0,s.Wm)("a",{class:"header-anchor",href:"#数据类型"},"#"),(0,s.Uk)(" 数据类型")],-1),r=(0,s.Wm)("p",null,"JavaScript 现在有八种数据类型，包括 7 个基础类型和 1 个引用类型。",-1),o=(0,s.Wm)("p",null,"基础类型：",-1),W=(0,s.Wm)("ol",null,[(0,s.Wm)("li",null,"空值（null）"),(0,s.Wm)("li",null,"未定义（undefined）"),(0,s.Wm)("li",null,"布尔值（ boolean）"),(0,s.Wm)("li",null,"数字（number）"),(0,s.Wm)("li",null,"字符串（string）"),(0,s.Wm)("li",null,"符号（symbol，ES6 新增）"),(0,s.Wm)("li",null,"对象（bigint，ES11 新增）")],-1),c=(0,s.Wm)("p",null,"引用类型：",-1),i=(0,s.Wm)("ol",null,[(0,s.Wm)("li",null,"对象(object)")],-1),p=(0,s.Wm)("h3",{id:"类型判断"},[(0,s.Wm)("a",{class:"header-anchor",href:"#类型判断"},"#"),(0,s.Uk)(" 类型判断")],-1),b=(0,s.Wm)("p",null,"一般我们可以用 typeof 运算符来查看值的类型，它返回的是类型的字符串值，值包括上述的八种，除了 null。",-1),d=(0,s.Wm)("div",{class:"language-text ext-text line-numbers-mode"},[(0,s.Wm)("pre",{class:"language-text"},[(0,s.Wm)("code",null,'  typeof null === "object"; // true\n')]),(0,s.Wm)("div",{class:"line-numbers"},[(0,s.Wm)("span",{class:"line-number"},"1"),(0,s.Wm)("br")])],-1),k=(0,s.Wm)("p",null,"这是历史遗留问题，因为第一版的 JavaScript 是用 32 位比特来存储值的，且是通过值的第 1 位或 3 位来识别类型的。而 null 表示为全 0，所以被错误地判断为 object。",-1),g=(0,s.Wm)("ol",null,[(0,s.Wm)("li",null,"1：整型（int）"),(0,s.Wm)("li",null,"000：引用类型（object）"),(0,s.Wm)("li",null,"010：双精度浮点型（double）"),(0,s.Wm)("li",null,"100：字符串（string）"),(0,s.Wm)("li",null,"110：布尔型（boolean）")],-1),h=(0,s.Wm)("p",null,[(0,s.Wm)("code",null,"JavaScript中的变量是没有类型的，只有值才有。--《你不知道的JavaScript（中卷）》")],-1),f=(0,s.Wm)("p",null,"js 还有很多内置对象，内置对象是对象的子类型，有 Function,Arguments,Math,Date,RegExp,Error。typeof 输出都是 object，除了 Function。 function 虽然本质也是对象，但是与普通对象相比，内部有一个[Call]方法，表示这个对象是可以调用的，typeof 操作符在判断 object 的时候，如果内部有[[Call]]方法就会返回 Function，这是一个特殊处理。",-1),v=(0,s.Wm)("p",null,"判断对象的子类型可以使用 instanceof，内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。",-1),U=(0,s.Wm)("div",{class:"language-text ext-text line-numbers-mode"},[(0,s.Wm)("pre",{class:"language-text"},[(0,s.Wm)("code",null,"function Car(make, model, year) {\n  this.make = make;\n  this.model = model;\n  this.year = year;\n}\nconst auto = new Car('Honda', 'Accord', 1998);\n\nconsole.log(auto instanceof Car);\n// expected output: true\n\nconsole.log(auto instanceof Object);\n// expected output: true\n")]),(0,s.Wm)("div",{class:"line-numbers"},[(0,s.Wm)("span",{class:"line-number"},"1"),(0,s.Wm)("br"),(0,s.Wm)("span",{class:"line-number"},"2"),(0,s.Wm)("br"),(0,s.Wm)("span",{class:"line-number"},"3"),(0,s.Wm)("br"),(0,s.Wm)("span",{class:"line-number"},"4"),(0,s.Wm)("br"),(0,s.Wm)("span",{class:"line-number"},"5"),(0,s.Wm)("br"),(0,s.Wm)("span",{class:"line-number"},"6"),(0,s.Wm)("br"),(0,s.Wm)("span",{class:"line-number"},"7"),(0,s.Wm)("br"),(0,s.Wm)("span",{class:"line-number"},"8"),(0,s.Wm)("br"),(0,s.Wm)("span",{class:"line-number"},"9"),(0,s.Wm)("br"),(0,s.Wm)("span",{class:"line-number"},"10"),(0,s.Wm)("br"),(0,s.Wm)("span",{class:"line-number"},"11"),(0,s.Wm)("br"),(0,s.Wm)("span",{class:"line-number"},"12"),(0,s.Wm)("br")])],-1),j=(0,s.Wm)("p",null,'typeof 只能判断基本数据类型，instanceof 可以判断对象的子类型，要更精确的判断数据类型，可以使用 Object.prototype.toString.call 方法，这方法会返回 "[object XXX]" 的字符串。',-1),y=(0,s.Wm)("p",null,"call 调用，是因为很多对象的 toString 方法被重写了。",-1),x=(0,s.Wm)("p",null,"总结类型判断：",-1),_=(0,s.Wm)("ol",null,[(0,s.Wm)("li",null,[(0,s.Uk)("利用 typeof 判断 "),(0,s.Wm)("ul",null,[(0,s.Wm)("li",null,"typeof 可以判断除 null 以外的基础类型，引用类型除了 Function，其他都返回 'object'")])]),(0,s.Wm)("li",null,[(0,s.Uk)("利用 instanceof 判断引用类型 "),(0,s.Wm)("ul",null,[(0,s.Wm)("li",null,"类似于 [] instanceof Array")])]),(0,s.Wm)("li",null,[(0,s.Uk)("利用 toString 判断引用类型 "),(0,s.Wm)("ul",null,[(0,s.Wm)("li",null,"类似于 Object.prototype.toString.call({}) === '[object Object]'")])])],-1),S=(0,s.Wm)("h2",{id:"作用域和闭包"},[(0,s.Wm)("a",{class:"header-anchor",href:"#作用域和闭包"},"#"),(0,s.Uk)(" 作用域和闭包")],-1),C=(0,s.Wm)("p",null,[(0,s.Uk)("作用域是根据名称查找变量的一套规则，作用域分为"),(0,s.Wm)("code",null,"全局作用域"),(0,s.Uk)("和"),(0,s.Wm)("code",null,"局部作用域"),(0,s.Uk)("、ES6的"),(0,s.Wm)("code",null,"块级作用域")],-1),w=(0,s.Wm)("p",null,"全局作用域：任何地方都能访问到的就是全局作用域",-1),J=(0,s.Wm)("ol",null,[(0,s.Wm)("li",null,"函数最外部定义的变量拥有全局作用域"),(0,s.Wm)("li",null,"未定义直接赋值的变量会自动声明为拥有全局作用域")],-1),E=(0,s.Wm)("div",{class:"language-javascript ext-js line-numbers-mode"},[(0,s.Wm)("pre",{class:"language-javascript"},[(0,s.Wm)("code",null,[(0,s.Wm)("span",{class:"token keyword"},"function"),(0,s.Uk)(" a "),(0,s.Wm)("span",{class:"token punctuation"},"{"),(0,s.Uk)("\n   b "),(0,s.Wm)("span",{class:"token operator"},"="),(0,s.Uk)(),(0,s.Wm)("span",{class:"token number"},"1"),(0,s.Uk)("\n"),(0,s.Wm)("span",{class:"token punctuation"},"}"),(0,s.Uk)("\n"),(0,s.Wm)("span",{class:"token function"},"a"),(0,s.Wm)("span",{class:"token punctuation"},"("),(0,s.Wm)("span",{class:"token punctuation"},")"),(0,s.Uk)("\nconsole"),(0,s.Wm)("span",{class:"token punctuation"},"."),(0,s.Wm)("span",{class:"token function"},"log"),(0,s.Wm)("span",{class:"token punctuation"},"("),(0,s.Uk)("b"),(0,s.Wm)("span",{class:"token punctuation"},")"),(0,s.Uk)(),(0,s.Wm)("span",{class:"token comment"},"//1 "),(0,s.Uk)("\n")])]),(0,s.Wm)("div",{class:"line-numbers"},[(0,s.Wm)("span",{class:"line-number"},"1"),(0,s.Wm)("br"),(0,s.Wm)("span",{class:"line-number"},"2"),(0,s.Wm)("br"),(0,s.Wm)("span",{class:"line-number"},"3"),(0,s.Wm)("br"),(0,s.Wm)("span",{class:"line-number"},"4"),(0,s.Wm)("br"),(0,s.Wm)("span",{class:"line-number"},"5"),(0,s.Wm)("br")])],-1),F=(0,s.Wm)("ol",{start:"3"},[(0,s.Wm)("li",null,"浏览器下window的属性拥有全局作用域")],-1),O=(0,s.Wm)("p",null,"局部作用域：在固定的代码片段内可访问到，一般是指函数里声明的，所以局部作用域也叫函数作用域。",-1),A=(0,s.Wm)("p",null,"局部变量只作用于函数内，在函数开始执行时创建，函数执行完后局部变量会自动销毁。",-1),X=(0,s.Wm)("p",null,"块级作用域：只在变量声明的代码块内有效（let、const）",-1),H=(0,s.Wm)("p",null,"作用域链：执行函数时先从函数内部寻找局部变量， 没找到就往上个作用域寻找，直到全局作用域为止，这个作用域之间行程的引用关系就是作用域链",-1),R=(0,s.Wm)("p",null,"闭包：在一个函数内返回一个新的函数，新的函数引用了外部函数的变量，这时候这个变量会存在堆里，在这个函数执行完后不会被销毁。这就形成了闭包。 闭包的目的是将变量放在局部作用域，保留这个引用，实现变量的隐藏。",-1),z=(0,s.Wm)("p",null,"下面是简单的例子，foo执行返回的函数保留了foo的局部变量，形成闭包",-1),D=(0,s.Wm)("div",{class:"language-text ext-text line-numbers-mode"},[(0,s.Wm)("pre",{class:"language-text"},[(0,s.Wm)("code",null,"function foo() {\n   var a = 1\n   return function() {\n      a++\n      console.log(a)\n   }\n}\nvar boo = foo()\n")]),(0,s.Wm)("div",{class:"line-numbers"},[(0,s.Wm)("span",{class:"line-number"},"1"),(0,s.Wm)("br"),(0,s.Wm)("span",{class:"line-number"},"2"),(0,s.Wm)("br"),(0,s.Wm)("span",{class:"line-number"},"3"),(0,s.Wm)("br"),(0,s.Wm)("span",{class:"line-number"},"4"),(0,s.Wm)("br"),(0,s.Wm)("span",{class:"line-number"},"5"),(0,s.Wm)("br"),(0,s.Wm)("span",{class:"line-number"},"6"),(0,s.Wm)("br"),(0,s.Wm)("span",{class:"line-number"},"7"),(0,s.Wm)("br"),(0,s.Wm)("span",{class:"line-number"},"8"),(0,s.Wm)("br")])],-1),M=(0,s.Wm)("p",null,[(0,s.Uk)("闭包缺点和解决方法：带有闭包的函数只要存在就会一直保留隐藏的局部变量，根据"),(0,s.Wm)("code",null,"垃圾回收"),(0,s.Uk)("的机制，被一个作用域引用的变量不会被回收，所以这个隐藏的局部变量将会一直存在，就造成了内存泄漏。解决方法就是销毁这个作用域，手动将这个函数对闭包变量的引用进行释放。接上面代码的例子：")],-1),N=(0,s.Wm)("div",{class:"language-text ext-text line-numbers-mode"},[(0,s.Wm)("pre",{class:"language-text"},[(0,s.Wm)("code",null,"boo = null\n")]),(0,s.Wm)("div",{class:"line-numbers"},[(0,s.Wm)("span",{class:"line-number"},"1"),(0,s.Wm)("br")])],-1),P=(0,s.Wm)("h2",{id:"原型链"},[(0,s.Wm)("a",{class:"header-anchor",href:"#原型链"},"#"),(0,s.Uk)(" 原型链")],-1),T=(0,s.Wm)("p",null,"每个函数都有 prototype 属性，这个属性就是原型，也是一个对象。创建的时候只有constructor一个属性，该属性指向构造函数本身。",-1),Y=(0,s.Wm)("p",null,[(0,s.Uk)("每个对象都有"),(0,s.Wm)("code",null,"__proto__"),(0,s.Uk)("属性，指向了创建该对象的构造函数的原型，也就是函数的prototype。这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使用 "),(0,s.Wm)("code",null,"__proto__"),(0,s.Uk)(" 来访问。")],-1),q=(0,s.Wm)("p",null,[(0,s.Uk)("为了实现继承的方式，通过 "),(0,s.Wm)("code",null,"__proto__"),(0,s.Uk)(" 将对象和原型联系起来组成原型链，得以让对象可以访问到不属于自己的属性。")],-1),B=(0,s.Wm)("p",null,[(0,s.Wm)("img",{src:a,alt:"图片"})],-1),G={render:function(l,n){return(0,s.wg)(),(0,s.j4)(s.HY,null,[m,t,u,r,o,W,c,i,p,b,d,k,g,h,f,v,U,j,y,x,_,S,C,w,J,E,F,O,A,X,H,R,z,D,M,N,P,T,Y,q,B],64)}}}}]);