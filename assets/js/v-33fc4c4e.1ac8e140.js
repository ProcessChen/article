(self.webpackChunkvuepress_starter=self.webpackChunkvuepress_starter||[]).push([[866],{4480:(n,s,a)=>{"use strict";a.r(s),a.d(s,{data:()=>e});const e={key:"v-33fc4c4e",path:"/blog/Vue2.html",title:"vue 面试题大全含源码级回答（vue2 篇）",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"1.vue 响应式原理",slug:"_1-vue-响应式原理",children:[]},{level:2,title:"2.v-if 和 v-for 哪个优先级高",slug:"_2-v-if-和-v-for-哪个优先级高",children:[]},{level:2,title:"3.key 的作用",slug:"_3-key-的作用",children:[]},{level:2,title:"4.双向绑定原理",slug:"_4-双向绑定原理",children:[]},{level:2,title:"5.nextTick 原理",slug:"_5-nexttick-原理",children:[]},{level:2,title:"6.data 为什么是函数",slug:"_6-data-为什么是函数",children:[]},{level:2,title:"7.组件通信方式",slug:"_7-组件通信方式",children:[]},{level:2,title:"8.computed、watch、method 有什么区别",slug:"_8-computed、watch、method-有什么区别",children:[]},{level:2,title:"9.生命周期",slug:"_9-生命周期",children:[{level:3,title:"1. beforeCreate、created：",slug:"_1-beforecreate、created",children:[]},{level:3,title:"2. beforeMount、mounted",slug:"_2-beforemount、mounted",children:[]},{level:3,title:"3. beforeUpdate、updated",slug:"_3-beforeupdate、updated",children:[]},{level:3,title:"4. beforeDestroy、destroyed",slug:"_4-beforedestroy、destroyed",children:[]},{level:3,title:"5. activated、deactivated",slug:"_5-activated、deactivated",children:[]}]},{level:2,title:"10.keep-alive 原理",slug:"_10-keep-alive-原理",children:[]},{level:2,title:"12.虚拟 dom 和 diff 算法",slug:"_12-虚拟-dom-和-diff-算法",children:[{level:3,title:"patch",slug:"patch",children:[]},{level:3,title:"patchVnode",slug:"patchvnode",children:[]},{level:3,title:"updateChildren",slug:"updatechildren",children:[]}]},{level:2,title:"13.Vuex 原理",slug:"_13-vuex-原理",children:[]}],filePathRelative:"blog/Vue2.md",git:{updatedTime:1617954552e3,contributors:[]}}},8202:(n,s,a)=>{"use strict";a.r(s),a.d(s,{default:()=>i});var e=a(6252);const p=(0,e.uE)('<h1 id="vue-面试题大全含源码级回答-vue2-篇"><a class="header-anchor" href="#vue-面试题大全含源码级回答-vue2-篇">#</a> vue 面试题大全含源码级回答（vue2 篇）</h1><h2 id="_1-vue-响应式原理"><a class="header-anchor" href="#_1-vue-响应式原理">#</a> 1.vue 响应式原理</h2><p>回答这个问题，首先要搞清楚什么叫响应式。通常 vue 中所说的响应式是指数据响应式，数据变化可以被检测并对这种变化做出响应的机制。而在 Vue 这种 MVVM 框架中，最重要的核心就是实现数据层和视图层的连接，通过数据驱动应用，数据变化，视图更新。Vue 中的方案是数据劫持+发布订阅模式。</p><p>vue 在初始化的时候会对数据进行劫持，包括 props，data，methods，computed，watcher，并根据数据类型来做不同处理.</p><p>如果是对象则采用 Object.defineProperty()的方式定义数据拦截:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> val<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token function">set</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      val <span class="token operator">=</span> v<span class="token punctuation">;</span>\n      <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>如果是数组，则覆盖数组的 7 个变更方法实现变更通知:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> arrayProto <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>\n<span class="token keyword">const</span> arrayMethods <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>arrayProto<span class="token punctuation">)</span><span class="token punctuation">[</span>\n  <span class="token punctuation">(</span><span class="token string">&quot;push&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;pop&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;shift&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;unshift&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;splice&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;sort&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;reverse&quot;</span><span class="token punctuation">)</span>\n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">method</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token function">def</span><span class="token punctuation">(</span>arrayMethods<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">mutator</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">original</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> result<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>这是数据劫持的部分，接下来说下视图更新的机制：</p><ol><li>由于 Vue 执行一个组件的 render 函数是由 Watcher 去代理执行的，Watcher 在执行前会把 Watcher 自身先赋值给 Dep.target 这个全局变量，等待响应式属性去收集它。</li><li>在组件执行 render 函数时访问了响应式属性，响应式属性就会精确的收集到当前全局存在的 Dep.target 作为自身的依赖。</li><li>在响应式属性发生更新时通知 Watcher 去重新调用<code>vm._update(vm._render())</code>进行组件的视图更新，视图更新的时候会通过 diff 算法对比新老 vnode 差异，通过 patch 即时更新 DOM。</li></ol><h2 id="_2-v-if-和-v-for-哪个优先级高"><a class="header-anchor" href="#_2-v-if-和-v-for-哪个优先级高">#</a> 2.v-if 和 v-for 哪个优先级高</h2><p>答案是 v-for 解析的优先级高，可以在源码的 compiler/codegen/index.js 里的 genElement 函数找到答案</p><div class="language-javscript ext-javscript line-numbers-mode"><pre class="language-javscript"><code>function genElement (el: ASTElement, state: CodegenState): string {\n  if (el.parent) {\n    el.pre = el.pre || el.parent.pre\n  }\n\n  if (el.staticRoot &amp;&amp; !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once &amp;&amp; !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for &amp;&amp; !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if &amp;&amp; !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === &#39;template&#39; &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) {\n    return genChildren(el, state) || &#39;void 0&#39;\n  } else if (el.tag === &#39;slot&#39;) {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    let code\n    if (el.component) {\n      code = genComponent(el.component, el, state)\n    } else {\n      let data\n      if (!el.plain || (el.pre &amp;&amp; state.maybeComponent(el))) {\n        data = genData(el, state)\n      }\n\n      const children = el.inlineTemplate ? null : genChildren(el, state, true)\n      code = `_c(&#39;${el.tag}&#39;${\n        data ? `,${data}` : &#39;&#39; // data\n      }${\n        children ? `,${children}` : &#39;&#39; // children\n      })`\n    }\n    // module transforms\n    for (let i = 0; i &lt; state.transforms.length; i++) {\n      code = state.transforms[i](el, code)\n    }\n    return code\n  }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><p>vue 中的内置指令都有相应的解析函数，执行顺序是通过简单的 if else-if 语法来确定的。在 genFor 的函数里，最后会 return 一个自运行函数，再次调用 genElement。</p><p>虽然 v-for 和 v-if 可以放一起，但我们要避免这种写法，在官网中也有明确指出，这会造成性能浪费。</p><h2 id="_3-key-的作用"><a class="header-anchor" href="#_3-key-的作用">#</a> 3.key 的作用</h2><p>作用：用来判断虚拟 DOM 的某个节点是否为相同节点，用于优化 patch 性能，patch 就是计算 diff 的函数。</p><p>先看下 patch 函数：</p><blockquote><p>只提取了本次要分析的关键代码</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token punctuation">,</span> vnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">invokeDestroyHook</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">let</span> isInitialPatch <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> insertedVnodeQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// empty mount (likely as component), create new root element</span>\n    isInitialPatch <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token function">createElm</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> isRealElement <span class="token operator">=</span> <span class="token function">isDef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>nodeType<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isRealElement <span class="token operator">&amp;&amp;</span> <span class="token function">sameVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// patch existing root node</span>\n      <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> removeOnly<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token comment">// some code</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> vnode<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>patch 函数接收 oldVnode 和 vnode，也就是要比较的新旧节点对象。</p><p>首先会用 isUndef 函数判断传入的两个 vnode 是否为空对象再做相应处理。当两个都为节点对象时，再用 sameVnode 来判断是否为同一节点，再判断本次操作是新增、修改、还是移除。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">sameVnode</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>\n    a<span class="token punctuation">.</span>key <span class="token operator">===</span> b<span class="token punctuation">.</span>key <span class="token operator">&amp;&amp;</span> <span class="token comment">// key值</span>\n    a<span class="token punctuation">.</span>tag <span class="token operator">===</span> b<span class="token punctuation">.</span>tag <span class="token operator">&amp;&amp;</span> <span class="token comment">// 标签名</span>\n    a<span class="token punctuation">.</span>isComment <span class="token operator">===</span> b<span class="token punctuation">.</span>isComment <span class="token operator">&amp;&amp;</span> <span class="token comment">// 是否为注释节点</span>\n    <span class="token function">isDef</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">isDef</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token comment">// 是否都定义了data，data包含一些具体信息，例如onclick , style</span>\n    <span class="token function">sameInputType</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token comment">// 当标签是&lt;input&gt;的时候，type必须相同</span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>sameVnode 通过判断 key、标签名、是否为注释、data 等是否相等，来判断是否需要进行比较。</p><p>值得比较则执行 patchVnode，不值得比较则用 Vnode 替换 oldVnode,再渲染真实 dom。</p><p>patchVnode 会对 oldVnode 和 vnode 进行对比，然后进行 DOM 更新。这个会在 diff 算法里再进行说明。</p><p>v-for 通常都是生成一样的标签，所以 key 会是 patch 判断是否相同节点的唯一标识，如果不设置 key，它的值就是 undefined，则可能永远认为这是两个相同节点，就会去做 pathVnode pdateChildren 的更新操作，这造成了大量的 dom 更新操作，所以设置唯一的 key 是必要的。</p><h2 id="_4-双向绑定原理"><a class="header-anchor" href="#_4-双向绑定原理">#</a> 4.双向绑定原理</h2><p>vue 中双向绑定是一个指令 v-model，可以绑定一个动态值到视图，同时视图中变化能改变该值。v-model 是语法糖，默认情况下相当于:value 和@input。</p><p>通常在表单元素可以直接使用 v-model，这是 vue 解析的时候对这些表单元素进行了处理，根据控件类型自动选取正确的方法来更新元素。</p><blockquote><p>v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 value property 和 input 事件；</li><li>checkbox 和 radio 使用 checked property 和 change 事件；</li><li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul></blockquote><p>如果是自定义组件的话要使用它需要在组件内绑定 props value 并在数据更新数据的时候用$emit(&#39;input&#39;)，也可以在组件里定义 modal 属性来自定义绑定的属性名和事件名称。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>model: {\n    prop: &#39;checked&#39;,\n    event: &#39;change&#39;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_5-nexttick-原理"><a class="header-anchor" href="#_5-nexttick-原理">#</a> 5.nextTick 原理</h2><p>先看下官方文档的说明：</p><blockquote><p>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。</p></blockquote><p>nextTick 就是将回调函数放到队列里去，保证在异步更新 DOM 的 watcher 后面，从而获取到更新后的 DOM。</p><p>结合 src/core/util/next-tick 源码再进行分析。</p><p>首先是定义执行任务队列方法</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function flushCallbacks () {\n  pending = false\n  const copies = callbacks.slice(0)\n  callbacks.length = 0\n  for (let i = 0; i &lt; copies.length; i++) {\n    copies[i]()\n  }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>按照推入 callbacks 队列的顺序执行回调函数。</p><p>然后定义 timerFunc 函数，根据当前环境支持什么方法来确定调用哪个异步方法</p><p>判断的顺序是: <code>Promise &gt; MutationObserver &gt; setImmediate &gt; setTimeout</code></p><p>最后是定义 nextTick 方法：</p><div class="language-javasscript ext-javasscript line-numbers-mode"><pre class="language-javasscript"><code>export function nextTick (cb?: Function, ctx?: Object) {\n  let _resolve\n  callbacks.push(() =&gt; {\n    if (cb) {\n      try {\n        cb.call(ctx)\n      } catch (e) {\n        handleError(e, ctx, &#39;nextTick&#39;)\n      }\n    } else if (_resolve) {\n      _resolve(ctx)\n    }\n  })\n  if (!pending) {\n    pending = true\n    timerFunc()\n  }\n  if (!cb &amp;&amp; typeof Promise !== &#39;undefined&#39;) {\n    return new Promise(resolve =&gt; {\n      _resolve = resolve\n    })\n  }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>其实 nextTick 就是一个把回调函数推入任务队列的方法。</p>',46),l=(0,e.Uk)("了解到这里也差不多了，再深入的话可以说 vue 中数据变化，触发 watcher，watcher 进入队列的流程，可以看我的另一篇文章"),t={href:"https://juejin.cn/post/6934539800527503368",target:"_blank",rel:"noopener noreferrer"},r=(0,e.Uk)("vue 中的 nextTick 完整解析"),o=(0,e.Uk)("。"),c=(0,e.uE)('<h2 id="_6-data-为什么是函数"><a class="header-anchor" href="#_6-data-为什么是函数">#</a> 6.data 为什么是函数</h2><p>如果组件里 data 直接写了一个对象的话，那么在模板中多次声明这个组件，组件中的 data 会指向同一个引用。</p><p>此时对 data 进行修改，会导致其他组件里的 data 也被修改。使用函数每次都重新声明一个对象，这样每个组件的 data 都有自己的引用，就不会出现相互污染的情况了。</p><h2 id="_7-组件通信方式"><a class="header-anchor" href="#_7-组件通信方式">#</a> 7.组件通信方式</h2><ol><li>props 和<code>$on</code>、<code>$emit</code></li></ol><p>适合父子组件的通信，通过 props 传递响应式数据，父组件通过<code>$on</code>监听事件、子组件通过<code>$emit</code>发送事件。</p><p>on 和 emit 是在组件实例初始化的时候通过<code>initEvents</code>初始化事件，在组件实例 vm._events 赋值一个空的事件对象，通过这个对象实现事件的发布订阅。下面是事件注册的几个关键函数：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 组件初始化event对象，收集要监听的事件和对应的回调函数\nfunction initEvents (vm: Component) {\n  vm._events = Object.create(null)\n  vm._hasHookEvent = false\n  // init parent attached events\n  const listeners = vm.$options._parentListeners\n  if (listeners) {\n    updateComponentListeners(vm, listeners)\n  }\n}\n...\n// 注册组件监听的事件\nfunction updateComponentListeners (\n  vm: Component,\n  listeners: Object,\n  oldListeners: ?Object\n) {\n  target = vm\n  updateListeners(listeners, oldListeners || {}, add, remove, createOnceHandler, vm)\n  target = undefined\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><ol start="2"><li><code>ref</code>、<code>$parent</code>、<code>$children</code>，还有<code>$root</code></li></ol><ul><li>ref: 在普通 DOM 元素上声明就是 DOM 元素的引用，组件就是指向组件实例。</li><li>$parent:访问组件的父组件实例</li><li>$children:访问所有的子组件集合(数组)</li><li>$root: 指向 root 实例</li></ul><ol start="3"><li>Event Bus</li></ol><p>通常是创建一个<code>空的Vue实例作为事件总线(事件中心)</code>，实现任何组件在这个实例上的事件触发与监听。原理就是一个发布订阅的模式，跟<code>$on``$emit</code>一样，在实例化一个组件的事件通过 initEvents 初始化一个空的 event 对象，再通过实例化后的这个 bus(vue 实例)手动的<code>$on</code>、<code>$emit</code>添加监听和触发的事件，代码在<code>src/core/instance/events</code>:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Vue.prototype.$on = function (event: string | Array&lt;string&gt;, fn: Function): Component {\n    const vm: Component = this\n    // 传入的事件如果是数组，就循环监听每个事件\n    if (Array.isArray(event)) {\n      for (let i = 0, l = event.length; i &lt; l; i++) {\n        vm.$on(event[i], fn)\n      }\n    } else {\n    // 如果已经有这个事件，就push新的回调函数进去，没有则先赋值空数组再push\n      (vm._events[event] || (vm._events[event] = [])).push(fn)\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true\n      }\n    }\n    return vm\n  }\n  ...\n  Vue.prototype.$emit = function (event: string): Component {\n    const vm: Component = this\n    ...\n    let cbs = vm._events[event]\n    // 循环调用要触发的事件的回调函数数组\n    if (cbs) {\n      cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs\n      const args = toArray(arguments, 1)\n      const info = `event handler for &quot;${event}&quot;`\n      for (let i = 0, l = cbs.length; i &lt; l; i++) {\n        invokeWithErrorHandling(cbs[i], vm, args, vm, info)\n      }\n    }\n    return vm\n  }\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><ol start="4"><li>$attrs、$listeners</li></ol><ul><li><code>$attrs</code>: 包含了父作用域<code>没被props声明</code>绑定的数据，组件可以通过<code>v-bind=&quot;$attrs&quot;</code>继续传给子组件</li><li><code>$listernes</code>: 包含了父作用域中的<code>v-on</code>(不含 .native 修饰器的) 监听事件，可以通过<code>v-on=&quot;$listeners&quot;</code>传入内部组件</li></ul><ol start="5"><li>provide、inject</li></ol><p>父组件通过 provide 注入一个依赖，其所有的子孙组件可以通过 inject 来接收。要注意的是官网有这一段话：</p><blockquote><p>提示：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。</p></blockquote><p>所以 Vue 不会对 provide 中的变量进行响应式处理。要想 inject 接受的变量是响应式的，provide 提供的变量本身就需要是响应式的。实际上在很多高级组件中都可以看到组件会将 this 通过 provide 传递给子孙组件，包括 element-ui、ant-design-vue 等。</p><ol start="6"><li>vuex 状态管理实现通信 vuex 是专为 vue 设计的状态管理模式。每个组件实例都有共同的 store 实例，并且 store.state 是响应式的，改变 state 唯一的办法就是通过在这个 store 实例上 commit 一个 mutation，方便跟踪每一个状态的变化，实现原理在下面的 vuex 原理里有讲。</li></ol><h2 id="_8-computed、watch、method-有什么区别"><a class="header-anchor" href="#_8-computed、watch、method-有什么区别">#</a> 8.computed、watch、method 有什么区别</h2><p>computed：有缓存，有对应的 watcher，watcher 有个 lazy 为 true 的属性，表示只有在模板里去读取它的值后才会计算，并且这 watcher 在初始化的时候会赋值 dirty 为 true，watcher 只有 dirty 为 true 的时候才会重新求值，重新求值后会将 dirty 置为 false，false 会直接返回 watcher 的 value，只有下次 watcher 的响应式依赖有更新的时候，会将 watcher 的 dirty 再置为 false，这时候才会重新求值，这样就实现了 computed 的缓存。</p><p>watch：watcher 的对象每次更新都会执行函数。watch 更适用于数据变化时的异步操作。如果需要在某个数据变化时做一些事情，使用 watch。</p><p>method: 将方法在模板里使用，每次视图有更新都会重新执行函数，性能消耗较大。</p><h2 id="_9-生命周期"><a class="header-anchor" href="#_9-生命周期">#</a> 9.生命周期</h2><p>官网对生命周期的说明：</p><blockquote><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。</p></blockquote><p>生命周期就是每个 Vue 实例完成初始化、运行、销毁的一系列动作的钩子。</p><p>基本上可以说 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</p><ul><li>创建前/后： 在 beforeCreate 阶段，vue 实例的挂载元素 el 还没有。</li><li>载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。</li><li>更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。</li><li>销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在</li></ul><p>结合源码再理解，在源码中生命周期钩子是用 callHook 函数调用的。看下 callHook 函数：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function callHook (vm: Component, hook: string) {\n  pushTarget()\n  const handlers = vm.$options[hook]\n  const info = `${hook} hook`\n  if (handlers) {\n    for (let i = 0, j = handlers.length; i &lt; j; i++) {\n      invokeWithErrorHandling(handlers[i], vm, null, vm, info)\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit(&#39;hook:&#39; + hook)\n  }\n  popTarget()\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>接收一个 vm 组件实例的参数和 hook，取组件实例的$options 传入的 hook 属性值，有的话会循环调用这个钩子的回调函数。在调用生命钩子的回调函数之前会临时 pushTarget 一个 null 值，也就是将 Dep.target 置为空来禁止在执行生命钩子的时候进行依赖收集。</p><p>vm.$emit(&#39;hook:&#39; + hook)则是用来给父组件监听该组件的回调事件。</p><p>接下来看每个生命钩子具体调用的时机。</p><h3 id="_1-beforecreate、created"><a class="header-anchor" href="#_1-beforecreate、created">#</a> 1. beforeCreate、created：</h3><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_init</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">options<span class="token operator">?</span><span class="token operator">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token operator">...</span>\n    <span class="token function">initLifecycle</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>\n    <span class="token function">initEvents</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>\n    <span class="token function">initRender</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>\n    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">&#39;beforeCreate&#39;</span><span class="token punctuation">)</span>\n    <span class="token function">initInjections</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// resolve injections before data/props</span>\n    <span class="token function">initState</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>\n    <span class="token function">initProvide</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// resolve provide after data/props</span>\n    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">&#39;created&#39;</span><span class="token punctuation">)</span>\n    <span class="token operator">...</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      vm<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>在执行 beforeCreate 之前调用了 <code>initLifecycle、initEvents、initRender</code>函数，所以 beforeCreate 是在初始化生命周期、事件、渲染函数之后的生命周期。</p><p>在执行 created 之前调用了 initInjections、initState、initProvide，这时候 created 初始化了 data、props、watcher、provide、inject 等，所以这时候就可以访问到 data、props 等属性。</p><h3 id="_2-beforemount、mounted"><a class="header-anchor" href="#_2-beforemount、mounted">#</a> 2. beforeMount、mounted</h3><p>在上面的代码片段可以看到 created 之后会进行 DOM 的挂载，执行的函数是 vm.$mount(vm.$options.el)，接下来分析下$mount 方法。</p><p>vm.$mount就是Vue.prototype.$mount 原型方法继承而来的。这个方法在<code>src/platforms/web/entry-runtime-with-compiler.js</code>下声明的，主要进行模板的解析，优先判断是否有 render 函数这个属性，没有再进行 tamplare 模板解析，最终都是用 render 函数进行渲染。</p><p>在解析完 render 函数后会调用 callHook(vm, &#39;beforeMount&#39;)，而后执行 vm._render()，再 callHook(vm, &#39;mounted&#39;)方法，这时候标记着 el 被新创建的 vm.$el 替换，并被挂载到实例上</p><h3 id="_3-beforeupdate、updated"><a class="header-anchor" href="#_3-beforeupdate、updated">#</a> 3. beforeUpdate、updated</h3><p>这两个钩子函数是在数据更新的时候进行回调的函数。在<code>src/core/instance/lifecycle.js</code>找到 beforeUpdate 调用的代码：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>...\nnew Watcher(vm, updateComponent, noop, {\n    before () {\n      if (vm._isMounted &amp;&amp; !vm._isDestroyed) {\n        callHook(vm, &#39;beforeUpdate&#39;)\n      }\n    }\n  }, true /* isRenderWatcher */)\n...\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>_isMounted 为 ture 的话（DOM 已经被挂载）会调用 callHook(vm, &#39;beforeUpdate&#39;)方法，然后会对虚拟 DOM 进行重新渲染。然后在/src/core/observer/scheduler.js 下的 flushSchedulerQueue()函数中渲染 DOM，flushSchedulerQueue 会刷新 watcher 队列并执行，执行完所有 watcher 的 run 方法之后（run 方法就是 watcher 进行 dom diff 并更新 DOM 的方法），再调用 callHook(vm, &#39;updated&#39;)，代码如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n ...\n\n for (index = 0; index &lt; queue.length; index++) {\n    watcher = queue[index]\n    if (watcher.before) {\n      watcher.before()\n    }\n    watcher.run()\n  }\n  ...\n  callUpdatedHooks(updatedQueue)\n ...\n}\n\nfunction callUpdatedHooks (queue) {\n  let i = queue.length\n  while (i--) {\n    const watcher = queue[i]\n    const vm = watcher.vm\n    if (vm._watcher === watcher &amp;&amp; vm._isMounted &amp;&amp; !vm._isDestroyed) {\n      callHook(vm, &#39;updated&#39;)\n    }\n  }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h3 id="_4-beforedestroy、destroyed"><a class="header-anchor" href="#_4-beforedestroy、destroyed">#</a> 4. beforeDestroy、destroyed</h3><p>这两个钩子是 vue 实例销毁的钩子，定义在 Vue.prototype.$destroy 中：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Vue.prototype.$destroy = function () {\n    const vm: Component = this\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, &#39;beforeDestroy&#39;)\n    vm._isBeingDestroyed = true\n    // remove self from parent\n    const parent = vm.$parent\n    if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) {\n      remove(parent.$children, vm)\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown()\n    }\n    let i = vm._watchers.length\n    while (i--) {\n      vm._watchers[i].teardown()\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--\n    }\n    // call the last hook...\n    vm._isDestroyed = true\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null)\n    // fire destroyed hook\n    callHook(vm, &#39;destroyed&#39;)\n    // turn off all instance listeners.\n    vm.$off()\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null\n    }\n    if (vm.$vnode) {\n      vm.$vnode.parent = null\n    }\n  }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><p>在销毁之前执行 callHook(vm, &#39;beforeDestroy&#39;)，然后销毁的时候做了几件事：</p><ul><li>如果有父元素，将父元素的$children 中把该组件实例移除。</li><li>移除 watchers，并在依赖订阅者中移除自己。</li><li>删除数据引用</li></ul><h3 id="_5-activated、deactivated"><a class="header-anchor" href="#_5-activated、deactivated">#</a> 5. activated、deactivated</h3><p>剩下的还有<code>activated、deactivated、errorCaptured</code>三个钩子函数。</p><p>activated、deactivated 这两个钩子函数分别是在 keep-alive 组件激活和停用之后的回调。</p><p>errorCaptured 捕获到当子孙组件错误时会被调用，在源码中可以经常看到 try catch 中 catch 会调用 handleError 函数，handleError 会向组件所有的父级组件抛出异常，</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function handleError (err: Error, vm: any, info: string) {\n  pushTarget()\n  try {\n    if (vm) {\n      let cur = vm\n      while ((cur = cur.$parent)) {\n        const hooks = cur.$options.errorCaptured\n        if (hooks) {\n          for (let i = 0; i &lt; hooks.length; i++) {\n            try {\n              const capture = hooks[i].call(cur, err, vm, info) === false\n              if (capture) return\n            } catch (e) {\n              globalHandleError(e, cur, &#39;errorCaptured hook&#39;)\n            }\n          }\n        }\n      }\n    }\n    globalHandleError(err, vm, info)\n  } finally {\n    popTarget()\n  }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>分析完源码再一下官网图示，会更清楚：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efe0499e41d24b8e9912d2e0cdd7423f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="_10-keep-alive-原理"><a class="header-anchor" href="#_10-keep-alive-原理">#</a> 10.keep-alive 原理</h2><p>keep-alive 是 Vue.js 的一个内置组件。它能够将不活动的组件实例保存在内存中，而不是直接将其销毁，它是一个抽象组件，不会被渲染到真实 DOM 中，也不会出现在父组件链中。</p><p>include 与 exclude 两个属性，允许组件有条件地进行缓存，max 属性确定最多缓存多少组件实例。</p><p>keep-alive 是一个组件，跟其他组件一样有生命周期和 render 函数，keep-alive 包裹的分析 keep-alive 就是分析一个组件。</p><p>源码再<code>src/core/components/keep-alive</code>，created 声明了要缓存的组件对象，和存储的组件 keys，keep-alive 销毁的时候会用 pruneCacheEntry 将缓存的所有组件实例销毁，也就是调用组件实例的 destroy 方法。在挂载完成后监听 include 和 exclude，动态地销毁已经不满足 include 的组件和满足 exclude 的组件实例:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>created () {\n    this.cache = Object.create(null) // 存储需要缓存的组件\n    this.keys = [] // 存储每个需要缓存的组件的key，即对应this.cache对象中的键值\n},\n\n// 销毁keep-alive组件的时候，对缓存中的每个组件执行销毁\ndestroyed () {\n    for (const key in this.cache) {\n      pruneCacheEntry(this.cache, key, this.keys)\n    }\n},\nmounted () {\n    this.$watch(&#39;include&#39;, val =&gt; {\n      pruneCache(this, name =&gt; matches(val, name))\n    })\n    this.$watch(&#39;exclude&#39;, val =&gt; {\n      pruneCache(this, name =&gt; !matches(val, name))\n    })\n},\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>接下来是 render 函数：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>render () {\n    const slot = this.$slots.default\n    const vnode: VNode = getFirstComponentChild(slot)\n    // 如果vnode存在就取vnode的选项\n    const componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions\n    if (componentOptions) {\n      // check pattern\n      //获取第一个有效组件的name\n      const name: ?string = getComponentName(componentOptions)\n      const { include, exclude } = this\n      if (\n        // not included\n        (include &amp;&amp; (!name || !matches(include, name))) ||\n        // excluded\n        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))\n      ) {\n        return vnode// 说明不用缓存，直接返回这个组件进行渲染\n      }\n\n      // 匹配到了，开始缓存操作\n      const { cache, keys } = this // keep-alive组件的缓存组件和缓存组件对应的key\n      // 获取第一个有效组件的key\n      const key: ?string = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : &#39;&#39;)\n        : vnode.key\n      if (cache[key]) {\n        // 这个组件的实例用缓存中的组件实例替换\n        vnode.componentInstance = cache[key].componentInstance\n        // make current key freshest\n        // 更新当前key在keys中的位置\n        remove(keys, key)\n        keys.push(key)\n      } else {\n        cache[key] = vnode\n        keys.push(key)\n        // prune oldest entry\n        // 如果缓存中的组件个数超过传入的max，销毁缓存中的LRU组件\n        // LRU: least recently used 最近最少用，缓存淘汰策略\n        if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode)\n        }\n      }\n\n      vnode.data.keepAlive = true\n    }\n    // 若第一个有效的组件存在，但其componentOptions不存在，就返回这个组件进行渲染\n    // 或若也不存在有效的第一个组件，但keep-alive组件的默认插槽存在，就返回默认插槽的第一个组件进行渲染\n    return vnode || (slot &amp;&amp; slot[0])\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br></div></div><p>代码做了详细的注释，这里再分析下 render 做了什么。</p><p>通过 this.$slots.default 拿到插槽组件，也就是 keep-alive 包裹的组件，getFirstComponentChild 获取第一个子组件，获取该组件的 name（存在组件名则直接使用组件名，否则会使用 tag）。接下来会将这个 name 通过 include 与 exclude 属性进行匹配，匹配不成功（说明不需要进行缓存）则不进行任何操作直接返回 vnode<code>（vnode节点描述对象，vue通过vnode创建真实的DOM）</code>。</p><p>匹配到了就开始缓存，根据 key 在 this.cache 中查找，如果存在则说明之前已经缓存过了，直接将缓存的 vnode 的 componentInstance（组件实例）覆盖到目前的 vnode 上面。否则将 vnode 存储在 cache 中。并且通过 remove(keys, key)，将当前的 key 从 keys 中删除再重新 keys.push(key)，这样就改变了当前 key 在 keys 中的位置。这个是为了实现 max 的功能，并且遵循缓存淘汰策略。</p><p>如果没匹配到，说明没缓存过，这时候需要进行缓存，并且判断当前缓存的个数是否超过 max 指定的个数，如果超过，则销毁 keys 里的最后一个组件，并从 keys 中移除，这个就是 LRU（<code>Least Recently Used ：最近最少使用 </code>）缓存淘汰算法。</p><p>最后返回 vnode 或者默认插槽的第一个组件进行 DOM 渲染。</p><h2 id="_12-虚拟-dom-和-diff-算法"><a class="header-anchor" href="#_12-虚拟-dom-和-diff-算法">#</a> 12.虚拟 dom 和 diff 算法</h2><p>虚拟 DOM 是对 DOM 的描述，用对象属性来描述节点，本质上是 JavaScript 对象。它有几个意义：</p><ol><li><p>具备跨平台的优势 由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器、小程序、Node、原生应用、服务端渲染等等。</p></li><li><p>提升渲染性能 频繁变动 DOM 会造成浏览器的回流或者重回，而通过将大量的 DOM 操作搬运到 Javascript 中，运用 patching 算法来计算出真正需要更新的节点，可以减少真实 DOM 的操作次数，从而提高性能。</p></li><li><p>代码可维护性更高 通过虚拟 DOM 的抽象能力，可以用声明式写 UI 的方式，大大提高了我们的工作效率。</p></li></ol><p>在 vue 中 template 最终会转成 render 函数，而 render 函数最终是执行的 createElement，生成 vnode，vnode 正是 vue 中用来表示虚拟 DOM 的类，看下 vnode：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">VNode</span> <span class="token punctuation">{</span>\n  tag<span class="token operator">:</span> string <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>\n  data<span class="token operator">:</span> VNodeData <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>\n  children<span class="token operator">:</span> <span class="token operator">?</span>Array<span class="token operator">&lt;</span>VNode<span class="token operator">&gt;</span><span class="token punctuation">;</span>\n  text<span class="token operator">:</span> string <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>\n  elm<span class="token operator">:</span> Node <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>\n  ns<span class="token operator">:</span> string <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>\n  context<span class="token operator">:</span> Component <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token comment">// rendered in this component&#39;s scope</span>\n  key<span class="token operator">:</span> string <span class="token operator">|</span> number <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>\n  componentOptions<span class="token operator">:</span> VNodeComponentOptions <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>\n  componentInstance<span class="token operator">:</span> Component <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token comment">// component instance</span>\n  parent<span class="token operator">:</span> VNode <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token comment">// component placeholder node</span>\n\n  <span class="token comment">// strictly internal</span>\n  raw<span class="token operator">:</span> boolean<span class="token punctuation">;</span> <span class="token comment">// contains raw HTML? (server only)</span>\n  isStatic<span class="token operator">:</span> boolean<span class="token punctuation">;</span> <span class="token comment">// hoisted static node</span>\n  isRootInsert<span class="token operator">:</span> boolean<span class="token punctuation">;</span> <span class="token comment">// necessary for enter transition check</span>\n  isComment<span class="token operator">:</span> boolean<span class="token punctuation">;</span> <span class="token comment">// empty comment placeholder?</span>\n  isCloned<span class="token operator">:</span> boolean<span class="token punctuation">;</span> <span class="token comment">// is a cloned node?</span>\n  isOnce<span class="token operator">:</span> boolean<span class="token punctuation">;</span> <span class="token comment">// is a v-once node?</span>\n  asyncFactory<span class="token operator">:</span> Function <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token comment">// async component factory function</span>\n  asyncMeta<span class="token operator">:</span> Object <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>\n  isAsyncPlaceholder<span class="token operator">:</span> boolean<span class="token punctuation">;</span>\n  ssrContext<span class="token operator">:</span> Object <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>\n  fnContext<span class="token operator">:</span> Component <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token comment">// real context vm for functional nodes</span>\n  fnOptions<span class="token operator">:</span> <span class="token operator">?</span>ComponentOptions<span class="token punctuation">;</span> <span class="token comment">// for SSR caching</span>\n  devtoolsMeta<span class="token operator">:</span> <span class="token operator">?</span>Object<span class="token punctuation">;</span> <span class="token comment">// used to store functional render context for devtools</span>\n  fnScopeId<span class="token operator">:</span> <span class="token operator">?</span>string<span class="token punctuation">;</span> <span class="token comment">// functional scope id support</span>\n\n  <span class="token function">constructor</span><span class="token punctuation">(</span>\n    <span class="token parameter">tag<span class="token operator">?</span><span class="token operator">:</span> string<span class="token punctuation">,</span>\n    data<span class="token operator">?</span><span class="token operator">:</span> VNodeData<span class="token punctuation">,</span>\n    children<span class="token operator">?</span><span class="token operator">:</span> <span class="token operator">?</span>Array<span class="token operator">&lt;</span>VNode<span class="token operator">&gt;</span><span class="token punctuation">,</span>\n    text<span class="token operator">?</span><span class="token operator">:</span> string<span class="token punctuation">,</span>\n    elm<span class="token operator">?</span><span class="token operator">:</span> Node<span class="token punctuation">,</span>\n    context<span class="token operator">?</span><span class="token operator">:</span> Component<span class="token punctuation">,</span>\n    componentOptions<span class="token operator">?</span><span class="token operator">:</span> VNodeComponentOptions<span class="token punctuation">,</span>\n    asyncFactory<span class="token operator">?</span><span class="token operator">:</span> Function</span>\n  <span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag<span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>children <span class="token operator">=</span> children<span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>text <span class="token operator">=</span> text<span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>elm <span class="token operator">=</span> elm<span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>ns <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> context<span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>fnContext <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>fnOptions <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>fnScopeId <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> data <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span>key<span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>componentOptions <span class="token operator">=</span> componentOptions<span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>componentInstance <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>raw <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>isStatic <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>isRootInsert <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>isComment <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>isCloned <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>isOnce <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>asyncFactory <span class="token operator">=</span> asyncFactory<span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>asyncMeta <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>isAsyncPlaceholder <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// DEPRECATED: alias for componentInstance for backwards compat.</span>\n  <span class="token comment">/* istanbul ignore next */</span>\n  <span class="token keyword">get</span> <span class="token function">child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Component <span class="token operator">|</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>componentInstance<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br></div></div><p>看下其中关键的几个属性：</p><ul><li><p>tag: 当前节点的标签名</p></li><li><p>data: 表示节点上的 class，attribute，style 以及绑定的事件</p></li><li><p>children: 当前节点的子节点，是一个数组</p></li><li><p>text: 当前节点的文本</p></li><li><p>elm: 当前虚拟节点对应的真实 dom 节点</p></li><li><p>key: 节点的 key 属性，被当作节点的标志，用以优化</p></li><li><p>componentOptions: 组件的 option 选项</p></li><li><p>componentInstance: 当前节点对应的组件的实例</p></li><li><p>parent: 当前节点的父节点</p></li><li><p>isStatic: 是否为静态节点</p></li></ul><p>children 和 parent 是指当前的 vnode 的子节点和父节点，这样一个个 vnode 就形成了 DOM 树。</p><p>diff 算法发生在<code>视图更新</code>的时候，也就是数据更新的时候，<code>diff算法会将新旧虚拟DOM作对比，将变化的地方转换为DOM</code>。</p><p>当某个数据被修改的时候，依赖对应的 watcher 会通知更新，执行渲染函数会生成新的 vnode，vnode 再去与旧的 vnode 进行对比更新，这就是 vue 中的虚拟 dom diff 算法触发的流程。</p><p>看下组件更新的_update 方法：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {\n    const vm: Component = this\n    const prevEl = vm.$el\n    const prevVnode = vm._vnode\n    const restoreActiveInstance = setActiveInstance(vm)\n    vm._vnode = vnode\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode)\n    }\n  }\n  ...\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>vm.$el = vm._patch（），这个就是最终渲染的 DOM 元素，patch 就是 vue 中 diff 算法的函数，在 key 的作用章节有提过。patch 将新旧虚拟 DOM 节点比较后，最终返回真实的 DOM 节点。</p><h3 id="patch"><a class="header-anchor" href="#patch">#</a> patch</h3><p>看下 patch 代码（部分）：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    /*vnode不存在则直接调用销毁钩子*/\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)\n      return\n    }\n\n    let isInitialPatch = false\n    const insertedVnodeQueue = []\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm)\n    } else {\n      /*标记旧的VNode是否有nodeType*/\n      /*Github:https://github.com/answershuto*/\n      const isRealElement = isDef(oldVnode.nodeType)\n      if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        /*是同一个节点的时候直接修改现有的节点*/\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)\n   ...\n   return vnode.elm\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>首先是判断是否有新的 vnode，没有代表是要销毁旧的 vnode，调用销毁组件的钩子。</p><p>然后判断是否有旧的 vnode，没有代表是新增，也就是新建 root 节点。</p><p>接下来判断旧的 vnode 是否是真实的元素，而不是组件，如果是组件并且用 someVnode 判断新旧节点是否是相同的节点（sameVnode 在 key 的作用章节有做解析），是进行 patchVnode，这时候进行真正的新老节点的 diff。<code>只有相同的节点才会进行diff算法！！！</code></p><h3 id="patchvnode"><a class="header-anchor" href="#patchvnode">#</a> patchVnode</h3><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function patchVnode (\n    oldVnode,\n    vnode,\n    insertedVnodeQueue,\n    ownerArray,\n    index,\n    removeOnly\n  ) {\n    // 两个vnode相同，说明不需要diff，直接返回\n    if (oldVnode === vnode) {\n      return\n    }\n\n    // 如果传入了ownerArray和index，可以进行重用vnode，updateChildren里用来替换位置\n    if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) {\n      // clone reused vnode\n      vnode = ownerArray[index] = cloneVNode(vnode)\n    }\n\n    const elm = vnode.elm = oldVnode.elm\n\n    // 如果oldVnode的isAsyncPlaceholder属性为true时，跳过检查异步组件，return\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue)\n      } else {\n        vnode.isAsyncPlaceholder = true\n      }\n      return\n    }\n    /*\n      如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），\n      并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），\n      那么只需要替换elm以及componentInstance即可。\n    */\n    if (isTrue(vnode.isStatic) &amp;&amp;\n      isTrue(oldVnode.isStatic) &amp;&amp;\n      vnode.key === oldVnode.key &amp;&amp;\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance\n      return\n    }\n\n    let i\n    const data = vnode.data\n    if (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) {\n      i(oldVnode, vnode)\n    }\n\n    const oldCh = oldVnode.children\n    const ch = vnode.children\n    if (isDef(data) &amp;&amp; isPatchable(vnode)) {\n      for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)\n      if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode)\n    }\n    /*如果这个VNode节点没有text文本时*/\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) &amp;&amp; isDef(ch)) {\n      // 两个vnode都定义了子节点，并且不相同，就对子节点进行diff\n        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)\n      } else if (isDef(ch)) {\n      // 如果只有新的vnode定义了子节点，则进行添加子节点的操作\n        if (process.env.NODE_ENV !== &#39;production&#39;) {\n          checkDuplicateKeys(ch)\n        }\n        if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#39;&#39;)\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)\n      } else if (isDef(oldCh)) {\n      // 如果只有旧的vnode定义了子节点，则进行删除子节点的操作\n        removeVnodes(oldCh, 0, oldCh.length - 1)\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, &#39;&#39;)\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text)\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode)\n    }\n  }\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br></div></div><p>通过代码可知，patchVnode 分为多种情况，分析下子节点的 diff 过程 <code>(oldCh 为 oldVnode的子节点，ch 为 Vnode的子节点)</code></p><ol><li>oldCh、ch 都定义了调用 updateChildren 再进行 diff</li><li>若 oldCh 不存在，ch 存在，首先清空 oldVnode 的文本节点，同时调用 addVnodes 方法将 ch 添加到 elm 真实 dom 节点当中</li><li>若 oldCh 存在，ch 不存在，则删除 elm 真实节点下的 oldCh 子节点</li><li>若 oldVnode 有文本节点，而 vnode 没有，那么就清空这个文本节点</li></ol><p><code>updateChildren</code>是子节点 diff 的函数，也是最重要的环节。</p><h3 id="updatechildren"><a class="header-anchor" href="#updatechildren">#</a> updateChildren</h3><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    // 声明oldCh和newCh的头尾索引和头尾的vnode，\n    let oldStartIdx = 0\n    let newStartIdx = 0\n    let oldEndIdx = oldCh.length - 1\n    let oldStartVnode = oldCh[0]\n    let oldEndVnode = oldCh[oldEndIdx]\n    let newEndIdx = newCh.length - 1\n    let newStartVnode = newCh[0]\n    let newEndVnode = newCh[newEndIdx]\n    let oldKeyToIdx, idxInOld, vnodeToMove, refElm\n\n    const canMove = !removeOnly\n\n    if (process.env.NODE_ENV !== &#39;production&#39;) {\n      checkDuplicateKeys(newCh)\n    }\n\n    while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx]\n        // 判断两边的头是不是相同节点\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n        oldStartVnode = oldCh[++oldStartIdx]\n        newStartVnode = newCh[++newStartIdx]\n        // 判断尾部是不是相同节点\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newEndVnode = newCh[--newEndIdx]\n        // 判断旧节点头部是不是与新节点的尾部相同，相同则把头部往右移\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)\n        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n        oldStartVnode = oldCh[++oldStartIdx]\n        newEndVnode = newCh[--newEndIdx]\n        // 判断旧节点尾部是不是与新节点的头部相同，相同则把头部往左移\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newStartVnode = newCh[++newStartIdx]\n      } else {\n       /*\n          生成一个key与旧VNode的key对应的哈希表\n        */\n        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n        } else {\n          vnodeToMove = oldCh[idxInOld]\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n            oldCh[idxInOld] = undefined\n            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n          }\n        }\n        newStartVnode = newCh[++newStartIdx]\n      }\n    }\n    // oldCh或者newCh遍历完，说明剩下的节点不是新增就是删除\n    if (oldStartIdx &gt; oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n    } else if (newStartIdx &gt; newEndIdx) {\n      removeVnodes(oldCh, oldStartIdx, oldEndIdx)\n    }\n  }\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br></div></div><p>首先给 startIndex 和 endIndex 来作为遍历的索引，在遍历的时候会先判断头尾节点是否相同，没有找到相同节点后再按照通用方式遍历查找；查找结束再按情况处理剩下的节点；借助 key 通常可以非常精确找到相同节点。</p><p>当 oldCh 或者 newCh 遍历完后(遍历完的条件就是 oldCh 或者 newCh 的 startIndex &gt;= endIndex )，说明剩下的节点为新增或者删除，这时候停止 oldCh 和 newCh 的 diff。</p><h2 id="_13-vuex-原理"><a class="header-anchor" href="#_13-vuex-原理">#</a> 13.Vuex 原理</h2><p>vuex 是什么，先看下官方的原话：</p><blockquote><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化</p></blockquote><p>这段话可以得出几个结论：<code>Vuex是为vue.js服务的</code>，而像 redux 与 react 是解耦的，然后 vuex 是状态管理模式，所有的状态以一种可预测的方式发生变化。</p><p>设计思想：</p><p>Vuex 的设计思想，借鉴了 Flux、Redux，将数据存放到全局的 store，再将 store 挂载到每个 vue 实例组件中，利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。</p><p>原理可以从使用方式开始分析。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Vue.use(Vuex); // 1. vue的插件机制，安装vuex\nlet store = new Vuex.Store({ // 2.实例化store，调用install方法\n \tstate,\n \tgetters,\n \tmodules,\n \tmutations,\n \tactions,\n \tplugins\n});\nnew Vue({ // 3.注入store, 挂载vue实例\n\tstore,\n\trender: h=&gt;h(app)\n}).$mount(&#39;#app&#39;);\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>Vue.use 是 vue 中的插件机制，内部会调用插件的 install 方法，vuex 的 install 方法：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>export function install (_Vue) {\n  if (Vue) {\n    if (process.env.NODE_ENV !== &#39;production&#39;) {\n      console.error(\n        &#39;[vuex] already installed. Vue.use(Vuex) should be called only once.&#39;\n      )\n    }\n    return\n  }\n  /*保存Vue，同时用于检测是否重复安装*/\n  Vue = _Vue\n  /*将vuexInit混淆进Vue的beforeCreate(Vue2.0)或_init方法(Vue1.0)*/\n  applyMixin(Vue)\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>vuex 是个全局的状态管理，全局有且只能有一个 store 实例，所以在 install 的时候会判断是否已经安装过了，这个就是单例模式，确保一个类只有一个实例。在第一次 install 的时候会 applyMixin，applyMixin 是<code>/src/mixin</code>导入的方法:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function (Vue) {\n  const version = Number(Vue.version.split(&#39;.&#39;)[0])\n\n  if (version &gt;= 2) {\n    Vue.mixin({ beforeCreate: vuexInit })\n  } else {\n    // override init and inject vuex init procedure\n    // for 1.x backwards compatibility.\n    const _init = Vue.prototype._init\n    Vue.prototype._init = function (options = {}) {\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit\n      _init.call(this, options)\n    }\n  }\n\n  /**\n   * Vuex init hook, injected into each instances init hooks list.\n   */\n\n  function vuexInit () {\n    const options = this.$options\n    // store injection\n    if (options.store) {\n      this.$store = typeof options.store === &#39;function&#39;\n        ? options.store()\n        : options.store\n    } else if (options.parent &amp;&amp; options.parent.$store) {\n      this.$store = options.parent.$store\n    }\n  }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>先是判断下 vue 的版本，这边分析 vue2 的逻辑。利用 Vue.mixin 混入的机制，在组件实例的 beforeCreate 调用 vuexInit 方法，首先判断 options 是否有 store，没有代表是 root 节点，这时候要进行 store 初始化，没有的话就取父组件的$store 赋值，这样就实现了全局共用唯一的 store 实例。</p><p>store 实现的源码在<code>src/store.js</code>，其中最核心的是响应式的实现，通过 resetStoreVM(this, state)调用，看下这个方法：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function resetStoreVM (store, state, hot) {\n  const oldVm = store._vm\n\n  // bind store public getters\n  store.getters = {}\n  // reset local getters cache\n  store._makeLocalGettersCache = Object.create(null)\n  const wrappedGetters = store._wrappedGetters\n  const computed = {}\n  forEachValue(wrappedGetters, (fn, key) =&gt; {\n    // use computed to leverage its lazy-caching mechanism\n    // direct inline function use will lead to closure preserving oldVm.\n    // using partial to return function with only arguments preserved in closure environment.\n    computed[key] = partial(fn, store)\n    Object.defineProperty(store.getters, key, {\n      get: () =&gt; store._vm[key],\n      enumerable: true // for local getters\n    })\n  })\n\n  // use a Vue instance to store the state tree\n  // suppress warnings just in case the user has added\n  // some funky global mixins\n  const silent = Vue.config.silent\n  Vue.config.silent = true\n  store._vm = new Vue({\n    data: {\n      $$state: state\n    },\n    computed\n  })\n  Vue.config.silent = silent\n\n  // enable strict mode for new vm\n  if (store.strict) {\n    enableStrictMode(store)\n  }\n\n  if (oldVm) {\n    if (hot) {\n      // dispatch changes in all subscribed watchers\n      // to force getter re-evaluation for hot reloading.\n      store._withCommit(() =&gt; {\n        oldVm._data.$$state = null\n      })\n    }\n    Vue.nextTick(() =&gt; oldVm.$destroy())\n  }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br></div></div><p>resetStoreVM 首先会遍历 wrappedGetters，使用 Object.defineProperty 方法对 store.getters 的每一个 getter 定义 get 方法，这样访问 this.$store.getter.test 就等同于访问 store._vm.test。</p><p>state 是通过 new 一个 Vue 对象来实现数据的“响应式化”，运用 Vue 的 data 属性来实现数据与视图的同步更新，computed 实现 getters 的计算属性。最终访问 store.state 也就是访问 store._vm.state。</p>',118),i={render:function(n,s){const a=(0,e.up)("OutboundLink");return(0,e.wg)(),(0,e.j4)(e.HY,null,[p,(0,e.Wm)("p",null,[l,(0,e.Wm)("a",t,[r,(0,e.Wm)(a)]),o]),c],64)}}}}]);