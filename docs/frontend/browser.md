# 浏览器

## 浏览器缓存

### service worker

Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能
使用 Service Worker的话，传输协议必须为 HTTPS,因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全
步骤

注册 Service Worker
监听到 install 事件以后就可以缓存需要的文件
下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存

是:可以直接读取缓存文件
否:请求数据

Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的
当 Service Worker 没有命中缓存的时候，就需要去调用 fetch 函数获取数据
也就是说，当没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据
但是不管是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会先从 Service Worker 中获取的内容

### Memory Cache

Memory Cache 也就是内存中的缓存，读取内存中的数据比磁盘快

内存缓存虽然读取高效，但是缓存持续性很短，会随着进程的释放而释放。一旦关闭 Tab 页面，内存中的缓存就被释放了

当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存

浏览器会把哪些文件放入内存:question:

浏览器会把解析完成的js与css放入内存中

特点

快速读取：将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取
时效性：一旦该进程关闭，则该进程的内存则会清空

### Disk Cache
Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上
在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的
可以根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求
即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据
哪些资源会被放入磁盘:question:

对于大文件来说，大概率是不存储在内存中的，反之优先
当前系统内存使用率高的话，文件也会优先存储进硬盘

特点

直接将缓存写入硬盘文件中
读取需要对硬盘上文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢
文件类型覆盖面大
容量大，存储时间可控

### Push Cache

Push Cache 是 HTTP2 协议新增的内容
当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。
特点

所有的资源都能被推送，但有一定的兼容性问题
可以推送 no-cache 和 no-store 的资源
一旦连接被关闭，Push Cache 就被释放
多个页面可以使用相同的 HTTP/2 连接，即可以使用同一份缓存
Push Cache 中的缓存只能被使用一次
浏览器可以拒绝接受已经存在的资源推送

当所有缓存都没有命中时,就会发起网络请求来获取资源

### 缓存策略

强缓存
协商缓存
优先级较高的是强缓存，当强缓存失效的情况下，才会走协商缓存流程

都是通过设置 HTTP Header 来实现的

## 渲染原理

## 阻塞渲染

## 本地存储

## web 安全

XSS（跨站脚本攻击）
CSRF（跨站请求伪造）

### 跨域（同源策略）

## 事件循环机制
